{
	0:默认设置
	1:应用程序组件(4大组件 Activities,Services,BroadcastReceivers,Content Providers)
	2:附件组件(Manifest,Fragments,Views,Layouts,Intents)
	3:Services(Started,Bound)
	4:BroadcastReceiver
	5:Content Provider 内容提供者
	6:Intent(活动,服务,广播 递意图)
}

{0:默认设置

	Setting
		关闭启动默认打开上次项目 Appearance & Behavior-> system settings –> 把Reopen last project on startup 取消勾选

		注释加//不在首行
			Editor -> Code Style –> Java ->Code Generation  把 Add a space at comment start 勾选

		快捷键(Keymap)
			复制一行 Duplicate Entire Lines 
			移动上一行 Move Line Down
			移动上一行 Move Line Up
}

{1:应用程序组件(4大组件 Activities,Services,BroadcastReceivers,Content Providers)
	Activities:描述UI,并且处理用户与机器屏幕的交互。
		一个活动标识一个具有用户界面的单一屏幕
		public class MainActivity extends Activity {}

	Services:处理与应用程序关联的后台操作。
		服务是运行在后台,执行长时间操作的组件。
		public class MyService extends Service {}

	BroadcastReceivers:处理Android操作系统和应用程序之间的通信。
		广播接收器简单地响应从其他应用程序或者系统发来的广播消息。
		public class MyReceiver  extends  BroadcastReceiver {}

	Content Providers:处理数据和数据库管理方面的问题。
		内容提供者组件通过请求从一个应用程序到另一个应用程序提供数据。
		public class MyContentProvider extends ContentProvider {}
}

{2:附件组件(Manifest,Fragments,Views,Layouts,Intents)
	有一些附件的组件用于以上提到的实体、他们之间逻辑、及他们之间连线的构造。这些组件如下：

	Manifest:应用程序的配置文件。
	Fragments:代表活动中的一个行为或者一部分用户界面。
	Views:绘制在屏幕上的UI元素,包括按钮,列表等。
	Layouts:控制屏幕格式,展示视图外观的View的继承。
	Intents:组件间的消息连线。
	Resources:外部元素,例如字符串资源、常量资源及图片资源等。
		这些资源一般放置在项目的 res/ 下独立子目录中。
		anim/	定义动画属性的XML文件。它们被保存在res/anim/文件夹下,通过R.anim类访问
		color/	定义颜色状态列表的XML文件。它们被保存在res/color/文件夹下,通过R.color类访问
		drawable/	图片文件,如.png,.jpg,.gif或者XML文件,被编译为位图、状态列表、形状、动画图片。它们被保存在res/drawable/文件夹下,通过R.drawable类访问
		layout/	定义用户界面布局的XML文件。它们被保存在res/layout/文件夹下,通过R.layout类访问
		menu/	定义应用程序菜单的XML文件,如选项菜单,上下文菜单,子菜单等。它们被保存在res/menu/文件夹下,通过R.menu类访问
		raw/	任意的文件以它们的原始形式保存。需要根据名为R.raw.filename的资源ID,通过调用Resource.openRawResource()来打开raw文件
		values/	包含简单值(如字符串,整数,颜色等)的XML文件。这里有一些文件夹下的资源命名规范。arrays.xml代表数组资源,通过R.array类访问；integers.xml代表整数资源,通过R.integer类访问；bools.xml代表布尔值资源,通过R.bool类访问；colors.xml代表颜色资源,通过R.color类访问；dimens.xml代表维度值,通过R.dimen类访问；strings.xml代表字符串资源,通过R.string类访问；styles.xml代表样式资源,通过R.style类访问
		xml/	可以通过调用Resources.getXML()来在运行时读取任意的XML文件。可以在这里保存运行时使用的各种配置文件

		import com.xx.xx.R;
			R.anim.*
			R.color.*
			R.drawable.*
			R.layout.*
			R.string.* res/values/strings.xml
}


{3:Services(Started,Bound)
	服务是一个后台运行的组件,执行长时间运行且不需要用户交互的任务。即使应用被销毁也依然可以工作。服务基本上包含两种状态

	Started:Android的应用程序组件,如活动,通过startService()启动了服务,则服务是Started状态。一旦启动,服务可以在后台无限期运行,即使启动它的组件已经被销毁。
		startService()->onCreate()->onStart()->Service is Running ->The service is stopped(no callback) ->onDestroy()->Service is Shut down

	Bound:当Android的应用程序组件通过bindService()绑定了服务,则服务是Bound状态。Bound状态的服务提供了一个客户服务器接口来允许组件与服务进行交互,如发送请求,获取结果,甚至通过IPC来进行跨进程通信。
		bindService()->onCreate()->onBind()->client interacts with the service ->onRebind()-->onUnbind() ->onDestroy()->Service is Shut down


	onStartCommand():其他组件(如活动)通过调用startService()来请求启动服务时,系统调用该方法。如果你实现该方法,你有责任在工作完成时通过stopSelf()或者stopService()方法来停止服务。
	onBind():当其他组件想要通过bindService()来绑定服务时,系统调用该方法。如果你实现该方法,你需要返回IBinder对象来提供一个接口,以便客户来与服务通信。你必须实现该方法,如果你不允许绑定,则直接返回null。
	onUnbind():当客户中断所有服务发布的特殊接口时,系统调用该方法。
	onRebind():当新的客户端与服务连接,且此前它已经通过onUnbind(Intent)通知断开连接时,系统调用该方法。
	onCreate():当服务通过onStartCommand()和onBind()被第一次创建的时候,系统调用该方法。该调用要求执行一次性安装。
	onDestroy():当服务不再有用或者被销毁时,系统调用该方法。你的服务需要实现该方法来清理任何资源,如线程,已注册的监听器,接收器等。

}

{4:BroadcastReceiver
	广播接收器用于响应来自其他应用程序或者系统的广播消息。这些消息有时被称为事件或者意图。例如,应用程序可以初始化广播来让其他的应用程序知道一些数据已经被下载到设备,并可以为他们所用。这样广播接收器可以定义适当的动作来拦截这些通信。

	有以下两个重要的步骤来使系统的广播意图配合广播接收器工作。

	创建广播接收器
	注册广播接收器
}

{5:Content Provider 内容提供者
	内容提供者组件通过请求从一个应用程序向其他的应用程序提供数据。这些请求由类 ContentResolver 的方法来处理。内容提供者可以使用不同的方式来存储数据。数据可以被存放在数据库,文件,甚至是网络。


}

{6:Intent(活动,服务,广播 递意图)
	意图本身（一个 Intent 对象）是一个被动的数据结构,保存着要执行操作的抽象描述。
	Android意图是一个要执行的操作的抽象描述。它可以通过 startActivity 来启动一个活动,broadcastIntent 来发送广播到任何对它感兴趣的广播接受器组件,startService(Intent) 或者bindService(Intent, ServiceConnection, int) 来与后台服务通讯。


	对于每一个组件-活动,服务,广播接收器都有独立的机制来传递意图。
		public abstract class Context {}
		Context.startActivity():意图传递给该方法,用于启动一个新的活动或者让已存在的活动做一些新的事情。
		Context.startService():意图传递给该方法,将初始化一个服务,或者新的信息到一个持续存在的服务。
		Context.sendBroadcast():意图传递给该方法,信息将传递到所有对此感兴趣的广播接收器。


		// 通过指定类名的显式意图,FirstActivity当前这个,跳转到SecondAcitivity
		Intent i = new Intent(FirstActivity.this, SecondAcitivity.class);
		// 启动目标活动
		startActivity(i);
}

{
	    implementation 'androidx.constraintlayout:constraintlayout:2.1.3'
}

{

	Android中让控件在布局中任意位置摆放的xml配置方法
	https://blog.csdn.net/achina2011jy/article/details/106997859



	布局{
		LinearLayout
		android.widget.RelativeLayout
		
		androidx.constraintlayout.widget.ConstraintLayout
		androidx.coordinatorlayout.widget.CoordinatorLayout  
	}

	ConstraintLayout={
		<?xml version="1.0" encoding="utf-8"?>
		<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
		    xmlns:app="http://schemas.android.com/apk/res-auto"
		    xmlns:tools="http://schemas.android.com/tools"
		    android:layout_width="match_parent"
		    android:layout_height="match_parent"
		    tools:context=".MainActivity">
		    <TextView
		        android:layout_width="wrap_content"
		        android:layout_height="wrap_content"
		        android:text="Hello World!"
		        app:layout_constraintBottom_toBottomOf="parent"
		        app:layout_constraintHorizontal_bias="0.674"
		        app:layout_constraintLeft_toLeftOf="parent"
		        app:layout_constraintRight_toRightOf="parent"
		        app:layout_constraintTop_toTopOf="parent"
		        app:layout_constraintVertical_bias="0.247" />
		</androidx.constraintlayout.widget.ConstraintLayout>
	}

}

{Button
	m_area_1 = findViewById(R.id.btn_Area_1);
    m_area_1.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v) {

        }
    });
}



















 
